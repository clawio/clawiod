package config

import (
	"errors"
	"sync"
)

func New(sources []ConfigSource) *Config {
	conf := &Config{}
	conf.configSources = sources
	return conf
}

type Config struct {
	dirs    *Directives
	dirsMux sync.Mutex

	configSources []ConfigSource
}

func (c *Config) GetDirectives() *Directives {
	c.dirsMux.Lock()
	defer c.dirsMux.Unlock()
	return c.dirs
}
func (c *Config) LoadDirectives() error {
	if len(c.configSources) == 0 {
		return errors.New("there are not configuration sources")
	}
	test := c.configSources[0]
	newDirs, err := test.LoadDirectives()
	if err != nil {
		return err
	}
	c.dirsMux.Lock()
	defer c.dirsMux.Unlock()
	c.dirs = newDirs
	return nil
}

type ConfigSource interface {
	LoadDirectives() (*Directives, error)
}

// Directives represents the different configuration options.
type Directives struct {
	Server         *Server `json:"server"`
	Authentication `json:"authenticaton"`
}

type Server struct {
	Port             int    `json:"port"`
	JWTSecret        string `json:"jwt_secret"`
	JWTSigningMethod string `json:"jwt_signing_method"`
	HTTPAccessLog    string `json:"http_access_log"`
	AppLog           string `json:"app_log"`
	ShutdownTimeout  int    `json:"shutdown_timeout"`
	TLSEnabled       bool   `json:"tls_enabled"`
	TLSCertificate   string `json:"tls_certificate"`
	TLSPrivateKey    string `json:"tls_private_key"`
}

type Authentication struct {
	Type   string                `json:"type"`
	Memory *AuthenticationMemory `json:"memory"`
	SQL    *AuthenticationSQL    `json:"sql"`
}

type AuthenticationMemory struct {
	Users []string `json:"users"`
}
type AuthenticationSQL struct {
	Driver string `json:"driver"`
	DSN    string `json:"dsn"`
}
